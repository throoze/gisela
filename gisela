#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ------------------------------------------------------------
# gisela
#
# Lexer para el lenguaje Gisela
# Julio Lopez (06-39821)
# Victor De Ponte (05-38087)
# ------------------------------------------------------------
import ply.lex as lex
import ply.yacc as yacc
from ply.lex import TOKEN
import sys
import re

# Lista de palabras reservadas del lenguaje Gisela
reserved = {
  'go':'TkGo',
  'og':'TkOg',
  'char':'TkChar',
  'bool':'TkBool',
  'int':'TkInt',
  'chr':'TkChr',
  'ord':'TkOrd',
  'isupper':'TkIsup',
  'isalpha':'TkIsal',
  'isdigit':'TkIsdig',
  'isspace':'TkIsspa',
  'xor':'TkXor',
  'and':'TkAnd',
  'or':'TkOr',
  'not':'TkNot',
  'div':'TkDiv',
  'mod':'TkMod',
  'skip':'TkSkip',
  'abort':'TkAbort',
  'read':'TkRead',
  'print':'TkPrint',
  'return':'TkReturn',
  'if':'TkIf',
  'do':'TkDo',
  'od':'TkOd',
  'proc':'TkProc',
  'var':'TkVar',
  }

# Lista de nombres de los tokens del lenguaje Gisela

tokens = [ 'TkLets', 'TkMsg', 'TkCaracter', 'TkTrue', 'TkFalse', 'TkPotencia',
           'TkProducto', 'TkSuma', 'TkResta', 'TkMenor', 'TkMenorIgual',
           'TkMayor', 'TkMayorIgual', 'TkIgual','TkFi',
           'TkDesIgual', 'TkAsignacion', 'TkParAbre', 'TkParCierra',
           'TkGuardia', 'TkIdent', 'TkNumero', 'TkComentario', 'TkComa',
           'TkPipe', 'TkSecuenciador' #, 'TkComillaSimple'
           ] + list(reserved.values())

# Expresión regular para la palabra reservada "let's"
def t_TkLets(t):
    r'let\'s'
    return t

# Expresion regular para los caracteres del lenguaje Gisela
def t_TkCaracter(t):
    r'("[^"]")|(\'[^\']\')|(_.)'
    return t

# Se diseño el token Msg y el token Caracter de esta forma pensando en que no
# deberían aceptarse cosas como esta " ads" as" como parte de un mensaje o algo
# como esto ''' como un caracter. Para el caso de que la variable char sea
# inicializada en ' pensamos que debería usarse comillas dobles o underscore
# algo como "'" o _'. (En la consulta habla solo de las cadenas, pero esta
# aclaración aplica para los char también por eso se incluye como comentario en
# el código.
def t_TkMsg(t):
    r'("(\\"|[^"])*")|(\'(\\\'|[^\'])*\')'
    #r'(?:"(?:[^"\\n\\r\\\\]|(?:"")|(?:\\\\x[0-9a-fA-F]+)|(?:\\\\.))*")|(?:\'(?:[^\'\\n\\r\\\\]|(?:\'\')|(?:\\\\x[0-9a-fA-F]+)|(?:\\\\.))*\')'
    return t

def t_TkTrue(t):
    r'(T|t)((R|r)((U|u)((E|e))?)?)?'
    return t

def t_TkFi(t):
    r'fi'
    return t

def t_TkFalse(t):
    r'(F|f)((A|a)((L|l)((S|s)((E|e))?)?)?)?'
    return t

# Definiendo las expresiones regulares simples del lenguaje Gisela
#t_TkComillaSimple = r'\''
t_TkPotencia = r'\*\*'
t_TkProducto = r'\*'
t_TkSuma = r'\+'
t_TkResta = r'-'
t_TkMenor = r'<'
t_TkMenorIgual = r'<='
t_TkMayor = r'>'
t_TkMayorIgual = r'=>'
t_TkIgual = r'=='
t_TkDesIgual = r'!='
t_TkAsignacion = r':='
t_TkParAbre = r'\('
t_TkParCierra = r'\)'
t_TkGuardia = r'->'
t_TkComa = r','
t_TkPipe = r'\|'
t_TkSecuenciador = r';'

# Expresion regular para los numeros del lenguaje Gisela
def t_TkNumero(t):
    r'\d+'
    if int(t.value) > 2**31-1:
        t.value = str(long(t.value))
        t.errormsg = "Gisela solo permite enteros almacenables en 32 bits. El numero:\n'" + t.value + "'\nexcede los 32 bits. Utilize numeros menores o iguales a " + str(2**31-1) + "."
        t.escadena = True
        t_error(t)
    t.value = int(t.value)
    return t

# Definicion de un comentario
def t_TkComentario(t):
    r'(//.*[\n\z])'
    t.lexer.lineno += 1

# Definicion de un identificador de variable
def t_TkIdent(t):
    r'[a-zA-Z][a-zA-Z0-9]*'
    t.type = reserved.get(t.value,'TkIdent')    # Chequea por las palabras
    return t                                    # reservadas

# Rastreo de numeros de linea
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

# Computa las columnas.
def find_column(input,t):
    last_cr = input.rfind('\n',0,t.lexpos)
    if last_cr < 0:
        last_cr = 0
    column = (t.lexpos - (last_cr + 1))
    if column < 0:
        column = 0
    return column

# Caracteres a ser ignorados
t_ignore  = ' \t'

# Definimos flag global para indicar que hay errores lexicos
lexerror = 0

# Manejador de Errores
def t_error(t):
    global lexerror
    lexerror = 1
    if hasattr(t, 'escadena'):
        unespected = "cadena de caracteres inesperada"
    else:
        unespected = "caracter inesperado"
    if hasattr(t, 'errormsg'):
        print "Error: %s '%s' en la fila '%d', columna '%d'.\n%s\n" %(unespected,t.value,t.lineno,find_column(data,t),t.errormsg)
    else:
        print "Error: %s '%s' en la fila '%d', columna '%d'\n" %(unespected,t.value[0],t.lineno,find_column(data,t))
    t.lexer.skip(1)

# Se construye el lexer
lexer = lex.lex()

# Le pasa la entrada al lexer
argc = len(sys.argv)
if argc < 2 :
    print ("GiSeLa:\nError: Debe ingresar el nombre del archivo a procesar")
    exit()
elif argc > 2 :
    print ("GiSeLa:\nError: Ud introdujo parámetros de más. Debe ingresar"
           +" sólo el nombre del archivo a procesar.")
    exit()
# p = re.compile('\w*\.gsl')
# if not p.match(sys.argv[1]) :
#     print ("GiSeLa:\nError: El archivo a procesar debe tener la extensión"
#            +" '.gsl'")
#     exit()
try:
    archi=open(sys.argv[1],'r')
except Exception, e:
    print ("GiSeLa:\nError: No se pudo abrir el archivo\n\t'"
           + sys.argv[1] + "'\nExcepción:")
    print unicode(e)
    exit()
data=archi.read()
archi.close()

# Tokenizador
# lexer.input(data)
# output = ""
# while True:
#     tok = lexer.token()
#     if not tok: break
#     output = (output + str(tok.type) + " " + '"' + str(tok.value) + '"' + " "
#     + "(Linea " + str(tok.lineno) + "," + " Columna "
#     + str(find_column(data,tok)) + ")" + "\n")
#En caso de que existan caracteres ilegales los tokens no son mostrados
# if lexerror == 0:
#     print output
#print output
######################## Hasta aqui el lexer ##########################

# Gramática legible:
# program     : ldef main ldef

# ldef        : def
#             | ldef def
#             | empty

# def         : defvar
#             | defproc

# defvar      : defv TkSecuenciador

# defv        : type lid

# lid         : TkIdent
#             | lid TkComa TkIdent

# type        : TkChar
#             | TkBool
#             | TkInt

# defproc     : TkProc TkIdent TkParAbre larg TkParCierra ldefvar instordef

# larg        : empty
#             | arg
#             | larg TkComa arg

# arg         : tvar type TkIdent

# tvar        : tkVar
#             | empty

# ldefvar     : empty
#             | defvar
#             | ldefvar defvar

# instordef   : inst
#             | defvar

# main        : TkLets block

# block       : TkGo previnst lastinst TkOg

# previnst    : linstanddef TkSecuenciador
#             | empty

# lastinst    : inst
#             | defvar

# linstanddef : instanddef
#             | linst TkSecuenciador instanddef

# instanddef  : inst
#             | defv

# inst        : simple
#             | guarded
#             | block
#             | selector
#             | repeat

# simple      : TkSkip
#             | TkAbort
#             | TkReturn
#             | asign
#             | io
#             | proc

# asign       : TkIdent TkAsignacion exp
#             | TkIdent TkComa asign TkComa exp

# exp         : boolexp
#             | arexp
#             | char

# boolexp     : TkTrue
#             | TkFalse
#             | TkIdent
#             | boolexp boolop boolexp
#             | TkNot boolexp
#             | arexp comp arexp
#             | char comp char
#             | isop char
#             | TkParAbre boolexp TkParCierra

# boolop      : TkXor
#             | TkAnd
#             | TkOr

# comp        : TkMayor
#             | TkMayorIgual
#             | TkMenor
#             | TkMenorIgual
#             | TkIgual
#             | TkDesIgual

# arexp       : arexp TkSuma term
#             | arexp TkResta term
#             | term

# term        : term TkProducto factor
#             | factor

# factor      : factor TkDiv div
#             | factor TkMod div
#             | div

# div         : div TkPotencia pow
#             | pow

# pow         : TkIdent
#             | TkNumero
#             | TkOrd char
#             | TkParAbre arexp TkParCierra
#             | TkResta arexp

# char        : TkChr arexp
#             | TkCaracter
#             | TkIdent

# isop        : TkIsup
#             | TkIsal
#             | TkIsdig
#             | TkIsspa

# io          : TkRead msg TkIdent
#             | TkPrint msg exp

# msg         : TkMsg
#             | empty

# proc        : TkIdent TkParAbre lexp TkParCierra

# lexp        : exp
#             | lexp TkComa exp

# guarded     : boolexp TkGuardia inst

# selector    : TkIf lguarded TkFi

# lguarded    : guarded
#             | lguarded TkPipe guarded

# repeat      : TkDo lguarded TkOd

# empty       :


# Reglas de asociatividad y precedencia:
precedence = (
    ('nonassoc','TkMayor','TkMayorIgual','TkMenor','TkMenorIgual','TkIgual','TkDesIgual'),
    ('left', 'TkSuma', 'TkResta'),
    ('left', 'TkProducto'),
    ('right', 'TkDiv', 'TkMod'),
    ('right', 'UMINUS'),
    ('right', 'TkPotencia'),
)

# Reglas de la gramática. Inicio del parser:
def p_program(p):
    ''' program : ldef main ldef '''
    pass

def p_ldef(p):
    ''' ldef : def
             | empty
             | ldef def'''
    pass

def p_def(p):
    ''' def : defvar
            | defproc'''
    pass

def p_defvar(p):
    ''' defvar : defv TkSecuenciador'''
    pass

def p_defv(p):
    ''' defv : type lid'''
    pass

def p_lid(p):
    ''' lid : TkIdent
            | lid TkComa TkIdent '''
    pass

def p_type(p):
    ''' type : TkChar
             | TkBool
             | TkInt '''
    pass

def p_defproc(p):
    ''' defproc : TkProc TkIdent TkParAbre larg TkParCierra ldefvar instordef'''
    pass

def p_larg(p):
    ''' larg : empty
             | arg
             | larg TkComa arg '''
    pass

def p_arg(p):
    ''' arg : tvar type TkIdent '''
    pass

def p_tvar(p):
    ''' tvar : TkVar
             | empty '''
    pass

def p_ldefvar(p):
    ''' ldefvar : empty
                | defvar
                | ldefvar defvar'''
    pass

def p_instordef(p):
    ''' instordef : inst
                  | defvar '''
    pass

def p_main(p):
    ''' main : TkLets block '''
    pass

def p_block(p):
    ''' block : TkGo previnst lastinst TkOg '''
    pass

def p_previnst(p):
    ''' previnst : linstanddef TkSecuenciador
                 | empty '''
    pass

def p_lastinst(p):
    ''' lastinst : inst
                 | defvar '''
    pass

def p_linstanddef(p):
    ''' linstanddef : instanddef
                    | linstanddef TkSecuenciador instanddef '''
    pass

def p_instanddef(p):
    ''' instanddef : inst
                   | defv '''
    pass

def p_inst(p):
    ''' inst : simple
             | guarded
             | block
             | selector
             | repeat '''
    pass

def p_simple(p):
    ''' simple : TkSkip
               | TkAbort
               | TkReturn
               | asign
               | io
               | proc '''
    pass

def p_asign(p):
    ''' asign : TkIdent TkAsignacion exp
              | TkIdent TkComa asign TkComa exp '''
    pass

def p_exp(p):
    ''' exp : boolexp
            | arexp
            | char '''
    pass

def p_boolexp(p):
    ''' boolexp : TkTrue
                | TkFalse
                | TkIdent
                | boolexp boolop boolexp
                | TkNot boolexp
                | arexp comp arexp
                | char comp char
                | isop char
                | TkParAbre boolexp TkParCierra '''
    pass

def p_boolop(p):
    ''' boolop : TkXor
               | TkAnd
               | TkOr '''
    pass

def p_comp(p):
    ''' comp : TkMayor
             | TkMayorIgual
             | TkMenor
             | TkMenorIgual
             | TkIgual
             | TkDesIgual '''
    pass

def p_arexp(p):
    ''' arexp : arexp TkSuma term
              | arexp TkResta term
              | term '''
    pass

def p_term(p):
    ''' term : term TkProducto factor
             | factor '''
    pass

def p_factor(p):
    ''' factor : factor TkDiv div
               | factor TkMod div
               | div '''
    pass

def p_div(p):
    ''' div : div TkPotencia pow
            | pow '''
    pass

def p_pow(p):
    ''' pow : TkIdent
            | TkNumero
            | TkOrd char
            | TkParAbre arexp TkParCierra
            | TkResta arexp %prec UMINUS'''
    pass

def p_char(p):
    ''' char : TkChr arexp
             | TkCaracter
             | TkIdent '''
    pass

def p_isop(p):
    ''' isop : TkIsup
             | TkIsal
             | TkIsdig
             | TkIsspa '''
    pass

def p_io(p):
    ''' io : TkRead msg TkIdent
           | TkPrint msg exp '''
    pass

def p_msg(p):
    ''' msg : TkMsg
            | empty '''
    pass

def p_proc(p):
    ''' proc : TkIdent TkParAbre lexp TkParCierra '''
    pass

def p_lexp(p):
    ''' lexp : exp
             | lexp TkComa exp '''
    pass

def p_guarded(p):
    ''' guarded : boolexp TkGuardia inst '''
    pass

def p_selector(p):
    ''' selector : TkIf lguarded TkFi '''
    pass

def p_lguarded(p):
    ''' lguarded : guarded
                 | lguarded TkPipe guarded '''
    pass

def p_repeat(p):
    ''' repeat : TkDo lguarded TkOd '''
    pass

def p_empty(p):
    ''' empty : '''
    pass

# Error rule for syntax errors
def p_error(p):
    #print unicode(p)
    if not p:
        print "Error sintáctico en token no identificado"
    else:
        print "Error sintáctico en el token ",p.type," ubicado en la linea ",p.lineno, ", columna ", find_column(data,p)
    # yacc.errok()

# Build the parser
parser = yacc.yacc()

#result = parser.parse("let's go print 'wepale' v og ; int v;")
result = parser.parse(data)
#print result
